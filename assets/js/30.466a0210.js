(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{437:function(a,t,e){"use strict";e.r(t);var r=e(2),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"hashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[a._v("#")]),a._v(" HashSet")]),a._v(" "),t("h4",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点：")]),a._v(" "),t("p",[a._v("HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。")]),a._v(" "),t("p",[a._v("HashSet 允许有 null 值。")]),a._v(" "),t("p",[a._v("HashSet 是无序的，即不会记录插入的顺序。")]),a._v(" "),t("p",[a._v("HashSet是Set的具体实现类。")]),a._v(" "),t("h4",{attrs:{id:"常用方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法"}},[a._v("#")]),a._v(" 常用方法：")]),a._v(" "),t("p",[a._v("HashSet是Set接口的典型实现，大多数时候使用Set集合时就是使用这个实现类:"),t("code",[a._v("Set<Integer> list=new HashSet<>();")])]),a._v(" "),t("p",[a._v("判断元素是否存在于集合当中:"),t("code",[a._v("contains()")])]),a._v(" "),t("p",[a._v("添加元素:"),t("code",[a._v("add()")])]),a._v(" "),t("p",[a._v("删除集合中的元素: "),t("code",[a._v("remove()")])]),a._v(" "),t("p",[a._v("删除集合中所有元素:"),t("code",[a._v("clear")])]),a._v(" "),t("p",[a._v("计算 HashSet 中的元素数量:"),t("code",[a._v("size()")])]),a._v(" "),t("h2",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("h4",{attrs:{id:"特点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),t("p",[a._v("简单来说：HashMap就是一个字典，通过Key能够以O(1)的时间复杂度直接获取到Key对应的值（Value）。")]),a._v(" "),t("h4",{attrs:{id:"常用方法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-2"}},[a._v("#")]),a._v(" 常用方法")]),a._v(" "),t("p",[a._v("添加与修改:"),t("code",[a._v("put(键名，键值)")])]),a._v(" "),t("p",[a._v("删除单条数据:"),t("code",[a._v("remove(键名)")])]),a._v(" "),t("p",[a._v("清除全部数据"),t("code",[a._v("clear()")])]),a._v(" "),t("p",[a._v("判断 hashMap 是否为空:"),t("code",[a._v("isEmpty()")])]),a._v(" "),t("p",[a._v("检查 hashMap 中是否存在指定的 key 对应的映射关系:"),t("code",[a._v("containsKey()")])]),a._v(" "),t("p",[a._v("如果存在相应的key则返回其对应的value，否则返回给定的默认值:"),t("code",[a._v("getOrDefault()")])]),a._v(" "),t("h2",{attrs:{id:"arraylist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[a._v("#")]),a._v(" ArrayList")]),a._v(" "),t("h4",{attrs:{id:"特点-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-3"}},[a._v("#")]),a._v(" 特点：")]),a._v(" "),t("p",[a._v("ArrayList是一个数组队列，相当于动态数组，可以不设置长度。")]),a._v(" "),t("p",[a._v("ArrayList能动态的增加和减少元素。")]),a._v(" "),t("h4",{attrs:{id:"常用方法-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-3"}},[a._v("#")]),a._v(" 常用方法:")]),a._v(" "),t("p",[a._v("判断该ArrayList中是否包含指定的内容:"),t("code",[a._v("contains()")])]),a._v(" "),t("p",[a._v("增加元素:"),t("code",[a._v("add()")])]),a._v(" "),t("p",[a._v("返回ArrayList对象第 index 下标的元素的值:"),t("code",[a._v("get(int index)")])]),a._v(" "),t("p",[a._v("删除ArrayList中与给定的元素“相等”的且第一次出现的元素:"),t("code",[a._v("remove()")])]),a._v(" "),t("p",[a._v("以Object[]形式返回ArrayList中存储的数据元素:"),t("code",[a._v("toArray()")])]),a._v(" "),t("p",[a._v("排序:"),t("code",[a._v("Collections.sort()")])]),a._v(" "),t("p",[a._v("将list直接转为Object[] 数组:"),t("code",[a._v("list.toArray()")])]),a._v(" "),t("p",[a._v("将list转化为需要类型的数组:"),t("code",[a._v("list.toArray(T[] a)")])]),a._v(" "),t("p",[a._v("Integer类型ArrayList转为int数组:"),t("code",[a._v("stream().mapToInt(Integer::intValue).toArray()")])]),a._v(" "),t("h2",{attrs:{id:"arrays-copyofrange"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arrays-copyofrange"}},[a._v("#")]),a._v(" Arrays.copyOfRange")]),a._v(" "),t("h4",{attrs:{id:"特点-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-4"}},[a._v("#")]),a._v(" 特点：")]),a._v(" "),t("p",[t("code",[a._v("Arrays.copyOfRange(T[ ] original,int from,int to)")])]),a._v(" "),t("p",[a._v("将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。")]),a._v(" "),t("p",[a._v("注意这里包括下标from，不包括上标to。比利用循环复制数组效率要高得多。")]),a._v(" "),t("h2",{attrs:{id:"stringbuilder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stringbuilder"}},[a._v("#")]),a._v(" StringBuilder")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_50617271/article/details/112686826",target:"_blank",rel:"noopener noreferrer"}},[a._v("StringBuilder的用法"),t("OutboundLink")],1)]),a._v(" "),t("h4",{attrs:{id:"特点-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-5"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),t("p",[a._v("字符缓冲区。字符串是常量，它们的值在创建之后不能更改，字符串缓冲区支持可变的字符串")]),a._v(" "),t("h4",{attrs:{id:"常用方法-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-4"}},[a._v("#")]),a._v(" 常用方法")]),a._v(" "),t("p",[a._v("追加数据:"),t("code",[a._v("append()")])]),a._v(" "),t("p",[a._v("换为String对象:"),t("code",[a._v("toString()")])]),a._v(" "),t("p",[a._v("向指定位置插入数据:"),t("code",[a._v("insert()")])]),a._v(" "),t("p",[a._v("删除指定位置的数据:"),t("code",[a._v("deleteCharAt()")])]),a._v(" "),t("p",[a._v("删除指定范围的数据(左闭右开):"),t("code",[a._v("delete( )")])]),a._v(" "),t("p",[a._v("将对象中的数据反转:"),t("code",[a._v("reverse()")])]),a._v(" "),t("h2",{attrs:{id:"stack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stack"}},[a._v("#")]),a._v(" Stack")]),a._v(" "),t("h4",{attrs:{id:"特点-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-6"}},[a._v("#")]),a._v(" 特点：")]),a._v(" "),t("p",[a._v("后进先出")]),a._v(" "),t("h4",{attrs:{id:"常用方法-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-5"}},[a._v("#")]),a._v(" 常用方法：")]),a._v(" "),t("p",[a._v("入栈:"),t("code",[a._v("push()")])]),a._v(" "),t("p",[a._v("出栈:"),t("code",[a._v("pop()")])]),a._v(" "),t("p",[a._v("读取栈顶元素的值，而不移除:"),t("code",[a._v("peek()")])]),a._v(" "),t("p",[a._v("判断是否为空:"),t("code",[a._v("isEmpty()")]),a._v("或"),t("code",[a._v("empty()")])]),a._v(" "),t("h2",{attrs:{id:"queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[a._v("#")]),a._v(" Queue")]),a._v(" "),t("h4",{attrs:{id:"特点-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-7"}},[a._v("#")]),a._v(" 特点:")]),a._v(" "),t("p",[a._v("先进先出")]),a._v(" "),t("h4",{attrs:{id:"常用方法-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-6"}},[a._v("#")]),a._v(" 常用方法:")]),a._v(" "),t("p",[a._v("LinkedList类实现Queue接口")]),a._v(" "),t("p",[a._v("入队:"),t("code",[a._v("add()")]),a._v("或"),t("code",[a._v("offer()")]),a._v("(当超出队列界限的时候，add()抛出异常，offer()直接返回false")]),a._v(" "),t("p",[a._v("移除并返回队列头部的元素:"),t("code",[a._v("remove()")])]),a._v(" "),t("p",[a._v("返回队列头部的元素:"),t("code",[a._v("peek()")])]),a._v(" "),t("p",[a._v("判断队列是否为空:"),t("code",[a._v("isEmpty()")])]),a._v(" "),t("h2",{attrs:{id:"deque"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#deque"}},[a._v("#")]),a._v(" Deque")]),a._v(" "),t("h4",{attrs:{id:"特点-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-8"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),t("p",[a._v("双端队列，既可以当作栈使用，也可以当作队列使用")]),a._v(" "),t("h4",{attrs:{id:"常用方法-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-7"}},[a._v("#")]),a._v(" 常用方法")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/SeekN/article/details/114231727",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java数据结构之Deque(双端队列)"),t("OutboundLink")],1),a._v(" "),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/549017380eab48d99e6635a1da4d6d59.png",alt:"在这里插入图片描述"}})]),a._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/5e4ee4cf2a2a441f9d539fe4e4bec051.png",alt:"Java双向队列Deque栈与队列"}})]),a._v(" "),t("h2",{attrs:{id:"priorityqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#priorityqueue"}},[a._v("#")]),a._v(" PriorityQueue")]),a._v(" "),t("h3",{attrs:{id:"特点-9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-9"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),t("p",[a._v("优先队列，先进优出。通过堆实现，通过完全二叉树实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值),保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）")]),a._v(" "),t("h3",{attrs:{id:"常用方法-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-8"}},[a._v("#")]),a._v(" 常用方法")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_36511997/article/details/121244158",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java 优先队列（PriorityQueue）总结"),t("OutboundLink")],1),a._v(" "),t("img",{attrs:{src:"https://img-blog.csdnimg.cn/b3892d5f50ae4977aca50f42e2ae4ede.png",alt:"在这里插入图片描述"}}),a._v(" "),t("code",[a._v("new PriorityQueue<>((x, y) -> (y - x));")]),a._v(":实现大顶堆")])])}),[],!1,null,null,null);t.default=v.exports}}]);